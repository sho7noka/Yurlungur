:orphan:

===================================
native Foundation
===================================

native
-------------------------------
言語に詳しい開発者がDCCツールに詳しいことはまれです。(私の経験上)
Mayaのことを多少知っていても、HoudiniとPhotoshopに詳しいエンジニアはほとんどいません。
静的な言語を普段書いている開発者は動的スクリプト言語でカスタマイズする機会も少ないです。

TAはアーティストとエンジニアを繋ぐ稀有な存在ですが、
自社エンジンにネイティブコードをコントリビュートする機会は少ないです。
アーティスト志向ではない内製ツールをより便利にするためには部署間の交渉がつきものですが、
多くの場合、それらの改善は遅々として進みません。

両者の言い分を聞いてみましょう。

artist
あの機能が使いにくい、もっと簡単にしてほしい
少しの修正や互換性のないアトリビュートの補完のためにもう一度DCCツールに戻るのはめんどくさい。

developper
優先度が低い割に機能を理解して実装するコストが高い
どうすればいいのか詳細な仕様を教えてもらえませんか

native は開発者に最小限の労力でアセット作成ツール間の連携機能を提供します。


.. code-block:: cpp

    #include native.h

    using namespace nt;

    nt::use("maya");
    auto node = nt::Node("");
    node->create();
    node.attr();
    nt::end();


APIを通して実際の処理を行うのはもちろん、詳細なパイプラインはTAに委任させるためには
pybind11 のエイリアスである eval メソッドをコールします。

main 関数内で呼ぶことで簡易的なcliの提供も可能です。

.. code-block:: cpp

    #include native.h

    using namespace nt;

    int main() {

    }

自社エンジンに関わらず、DCCアプリケーション間のやり取りも
ホストアプリに組み込むことでイテレーション速度の向上が期待できます。
特に標準でPythonInterpreterの提供を行っていないアプリにプラグイン形式で組み込むことで
相互運用が簡単に実現できます。


.. code-block:: cpp

    #include <openmaya.h>
    #include native.h
    #include yurlungur-native.h

    yr::use(maya);
    yr::YNode().create();
    yr::end();


精緻な絵を描いたりリアルなモデリングを開発者がすることは難しいですが、
グラフィクスAPIに沿ったデータをDCCツールからc++を通して取り出すのは簡単です。
